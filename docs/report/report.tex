\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[sorting=nyt,citestyle=authoryear]{biblatex}
\addbibresource{report.bib}
\usepackage[normalem]{ulem}
\usepackage{hyperref}
\usepackage{libertine}
\usepackage[scaled=0.89]{inconsolata}
\usepackage[showframe=false,bottom=6em,head=8em]{geometry}
\usepackage[iso,danish]{isodate}
\usepackage{fancyvrb}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\lhead{FF501 Consensus in Distributed Systems}
\rhead{\today}
\chead{}
\lfoot{J. R. Fagerberg, M. Møller, L. O. J. Olsen, P. H. Ratgen, T. Stenhaug}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\footrulewidth}{0pt}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}

\date{\today}
\title{FF501 Consensus in Distributed Systems}
\author{
  Johan Ringmann Fagerberg \\
  Marcus Møller \\
  Lucas Olai Jarlkov Olsen \\
  Peter Heilbo Ratgen \\
  Thomas Stenhaug
}

\pagenumbering{roman}

\begin{document}

\maketitle

\setlength{\baselineskip}{1.44\baselineskip}

\begin{abstract}

Clock synchronization is a widely known problem that has many applications. E.g. multiple clients in a distributed system must agree on a single time in order to successfully tackle a problem. The problem has been worked on since the birth of computer networks, and solutions have evolved over time in response to changing demands. In recent years, consensus based algorithms have gained traction with the propagation of Internet of Things, and several new algorithms have been developed as a result.

We will compare two recent consensus-based algorithms for clock synchronization in distributed systems, Average TimeSync (ATS) and Maximum Minimum Time Sync (MMTS), and implement them. The comparison will be based on the theoretical work from the algorithms' authors, our own analysis, and an implementation of both algorithms in virtual distributed networks.
\end{abstract}

\clearpage
\tableofcontents
\clearpage

\pagenumbering{arabic}
\setcounter{page}{1}

\section{Preface}

\section{Introduction}

Problem statement etc.

Nullam eu ante vel est convallis dignissim.  Fusce suscipit, wisi nec
facilisis facilisis, est dui fermentum leo, quis tempor ligula erat
quis odio.  Nunc porta vulputate tellus.  Nunc rutrum turpis sed pede.
Sed bibendum.  Aliquam posuere.  Nunc aliquet, augue nec adipiscing
interdum, lacus tellus malesuada massa, quis varius mi purus non odio.
Pellentesque condimentum, magna ut suscipit hendrerit, ipsum augue
ornare nulla, non luctus diam neque sit amet urna.  Curabitur
vulputate vestibulum lorem.  Fusce sagittis, libero non molestie
mollis, magna orci ultrices dolor, at vulputate neque nulla lacinia
eros.  Sed id ligula quis est convallis tempor.  Curabitur lacinia
pulvinar nibh.  Nam a sapien.

\section{Introduction (WIP)}

\subsection{Distributed systems}

A definition of \textit{distributed system} is
\begin{quote}
  A distributed system is a collection of autonomous computing
  elements that appears to its users as a single, coherent
  system.\cite{TanenbaumSteen06}
\end{quote}

The computing elements are typically called
nodes\cite{TanenbaumSteen06}, which is the term we will use within.
Nodes can be both hardware units, of software processes, while
\textit{users} might refer both to humans and software processes.

An example of a distributed system is multiplayer online game, where
the game environment is experienced as a single system, while there
are several nodes concerting the unified experience.  Another example
is the World Wide Web, which you can view as a large key-value store,
where Uniform Resource Locatiors (URL) are the key, and (typically)
HTML-pages are their value.  In the case of the WWW, both humans and
processes can considered users; indexing crawlers like Google are
examples of computer process users.  The type of distributed systems
we have studied, are \textit{Wireless Sensor Network}s (WSN), which is
discussed further below.

The type of distributed systems we have studied, are wireless sensor
networks.  Here, the nodes are small, cheap devices, equipped with the
ability to monitor environmental variables, like temperature,
humidity, sound pollution and so on. [cite?]

\subsection{Consensus}

Autonomous nodes that are to appear as a single system must share some
state.  For contrast, systems where there are master and slave nodes,
synchronization of shared data is achieved by pushing data from the
master to the slaves.  When nodes are ``peers'', consensus must be
reached by other means, and it must be reached in the face of faulty
or malicious nodes.

An example of faults, \textit{Byzantine faults}, were described in
Lamport, Shostak and Pease in a 1982 paper \cite{Lamport82}.  A group
of Byzantine generals, each general commanding a division, is
besieging a city.  They must reach an agreement on whether to all
attack or all retreat, and they can only communicate through messages.
There might be traiterous generals (faulty nodes), which send
different messages to different generals while loyal generals always
send the same message to all generals.

\subsection{Clock Synchronization}

There is not really a global clock in distributed systems.  In WSNs in
particular, it is too expensive to have an atomic clock at every node.

Depending on the application of the distributed system, different
``levels'' of synchronization might be chosen.  

Logical clocks \cite{Lamport78}, are chosen when it's only the strong
ordering of events within the system that is necessary.  If $c(x)$ is
a function of the system's ``clock'' at the point when event $x$.  Using
$a \rightarrow b$ to mean $a$ precedes $b$, then the strong clock condition is that
$a \rightarrow b \Rightarrow c(a) \rightarrow c(b)$

[TDSM, sync with atomic, prior protocols?]

\section{Theory}

\subsection{A distributed system}

At first we need to define the term "distributed system". In \cite{Lamport78} a distributed system is defined as "a collection of distinct processes which are spatially separated and communicate to with one another by exchanging messages". These processes are also referred to as nodes. As stated in \cite{TanenbaumSteen06} these nodes either be software or hardware processes. These processes are programmed to achieve common goals, through working to together, and further passing messages. 


%Maybe elaborate a bit on this (although it shouldn't be "nice to have" knowledge, as per the report course).



\subsection{Time synchronization}

%Describe the time synchronization problem. Why is it necessary? Why is it not trivial?

    %Clock drift

In such a system where passing messages between nodes is essential and each node is separated. A single unified notion of time becomes an issue. Each node has a crystal, which keeps time. 

    %Time sync in 
 

%Describe the advantages and disadvantages of the different kinds of time synchronization strategies (non-consensus vs. consensus)
    
%Describe algorithms Average TimeSync and Modified Maximum Time Sync.

\section{Analysis}%Or comparison

Analyze the consensus-based algorithms Average TimeSync and Modified Maximum Time Sync. 

Compare the algorithms, their advantages and disadvantages, and their areas of application (through both implementation and theoretical analysis).

\section{Results}


\section{Discussion}

\section{Process analysis}%Not supposed to be in the report. Needs to be a separate document.

\section{Conclusion}



\nocite{*} % print all bibliography, remove when actual citations are in place
\printbibliography


\end{document}